#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>

unsigned char rcon[256] = {
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
}

unsigned char gmul(unsigned char a, unsigned char b) {
  unsigned char p = 0;
  unsigned char counter;
  unsigned char carry;
  for(counter = 0; counter < 8; counter++) {
    if((b & 1) == 1) { 
      // 1) If the rightmost bit of b is set, XOR p with a.
      p ^= a;
    }
    // 2) Shift b one bit to the right.
    b >>= 1;
    // 3) Keep track of whether the leftmost bit of a is set to one and call this value carry.
    carry = (a & 0x80);
    // 4) Shift a one bit to the left, discarding the leftmost bit, and making the new rightmost bit zero. 
    a <<= 1;
    // 5) If carry had a value of one, XOR a with 0x1b.
    if(carry == 0x80) 
      a ^= 0x1b;	
  }
  return p;
}

void gmix_column2(unsigned char *r) {
  unsigned char a[4];
  unsigned char b[4];
  unsigned char c;
  unsigned char h;	
  for(c=0;c<4;c++) {
    a[c] = r[c];
    h = r[c] & 0x80; /* hi bit */
    b[c] = r[c] << 1;
    if(h == 0x80) 
      b[c] ^= 0x1b; /* Rijndael's Galois field */
  }
  r[0] = b[0] ^ a[3] ^ a[2] ^ b[1] ^ a[1];
  r[1] = b[1] ^ a[0] ^ a[3] ^ b[2] ^ a[2];
  r[2] = b[2] ^ a[1] ^ a[0] ^ b[3] ^ a[3];
  r[3] = b[3] ^ a[2] ^ a[1] ^ b[0] ^ a[0];
  printf("r is [%d %d %d %d]!\n", r[0], r[1], r[2], r[3]); 
}

void gmix_column(unsigned char *r) {
  unsigned char a[4];
  unsigned char b[4];
  unsigned char c;
  unsigned char h;
  unsigned char x = 0;
  /* The array 'a' is a copy of input array 'r'
   * The array 'b' is each element of the array 'a' multiplied by 2 in Rijndael's Galois field
   * a[n] ^ b[n] is element n multiplied by 3 in Rijndael's Galois field */ 
  for(c=0;c<4;c++) {
    a[c] = r[c];
    // b[c] = gmul(r[c],2);
    /* h is 0xff if the high bit of r[c] is set, 0 otherwise */
    h = (unsigned char)((signed char)r[c] >> 7); /* arithmetic right shift, thus shifting in either zeros or ones */
    b[c] = r[c] << 1; /* implicitly removes high bit because b[c] is an 8-bit char, so we xor by 0x1b and not 0x11b in the next line */
    b[c] ^= (0x1b & h); /* Rijndael's Galois field */
    printf("h without the conversions: %d , h with the conversions: %d\n", r[c]>>7, h);

  }
  r[0] = b[0] ^ a[3] ^ a[2] ^ b[1] ^ a[1]; /* 2 * a0 + a3 + a2 + 3 * a1 */
  r[1] = b[1] ^ a[0] ^ a[3] ^ b[2] ^ a[2]; /* 2 * a1 + a0 + a3 + 3 * a2 */
  r[2] = b[2] ^ a[1] ^ a[0] ^ b[3] ^ a[3]; /* 2 * a2 + a1 + a0 + 3 * a3 */
  r[3] = b[3] ^ a[2] ^ a[1] ^ b[0] ^ a[0]; /* 2 * a3 + a2 + a1 + 3 * a0 */
  printf("r is [%d %d %d %d]!\n", r[0], r[1], r[2], r[3]); 
}

int main()
{
  unsigned char n[4]; /* n is an array of 10 integers */
  int i,j;

  n[0] = 219;
  n[1] = 19; 
  n[2] = 83;
  n[3] = 69;

  gmix_column(n);

  n[0] = 219;
  n[1] = 19; 
  n[2] = 83;
  n[3] = 69;

  gmix_column2(n);
  
  unsigned char a = gmul(128,2);
  printf("%d is the result!\n", a);
}
